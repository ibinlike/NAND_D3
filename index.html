<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <script src="https://d3js.org/d3.v3.min.js"></script>
  <script src="http://d3js.org/queue.v1.min.js"></script>
  <script src="https://d3js.org/d3-color.v1.min.js"></script>
  <script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
  <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
  <script src="https://d3js.org/d3-scale.v1.min.js"></script>

  <style>
  h2 {
    text-align: center;
    color: black;
  }
  </style>
  <script type="text/javascript">
  </script>

</head>
<body>
  <script type="text/javascript">
  /*
    Use D3 to load the GeoJSON file
    */
var margin = 75,
    width = 1400 - margin,
    height = 600 - margin;

d3.select("body")
  .append("h2")
  .text("中国主要城市大气AQI分布 ")

var svg = d3.select("body")
    .append("svg")
    .attr("width", width + margin)
    .attr("height", height + margin)
    .append('g')
    .attr('class', 'map');


var projection = d3.geo.mercator()
                       .center([104,30])
                       .scale(700)
                       .translate( [width / 2, height / 1.2]);

var path = d3.geo.path().projection(projection);


//start to load the tsv file

queue()
  .defer(d3.json, "./data/cities.json")
  .defer(d3.json, "./data/china.json")
  .defer(d3.tsv, "./data/aqi.tsv")
  .await(draw);

function draw(error, cities, province, data) {

    var format = d3.time.format("%m/%d/%Y")

    data.forEach(function(d){
        d['date'] = format.parse(d['date']);
      })

    var color = d3.scaleSequential()
                  .domain([0,625])
                  .interpolator(d3.interpolateYlOrBr);

    function agg_year(leaves) {
      var averageAQI = d3.mean(leaves, function(d){
        return d['aqi'];
      });
      return {
        'aveAQI' : averageAQI
      };
    }

    var nested = d3.nest()
                   .key(function(d){
                     return d['date'].getUTCFullYear();
                   })
                   .key(function(d){
                     return d['city']
                   })
                   .rollup(agg_year)
                   .entries(data);

    //debugger;
    // svg.selectAll('.cities')
    //    .data(cities.features)
    //    .enter()
    //    .append('path')
    //    .attr('d', path)
    //    .attr('class', 'cities')
    //    .style('fill', "#ccc")
    //    .style('stroke', 'green')
    //    .style('stroke-width', 0.2);

     svg.selectAll(".province")
        .data(province.features)
        .enter()
        .append('path')
        .attr('d', path)
        .attr('class', 'province')
        .style('fill', '#fff5eb')
        .style('stroke', 'black')
        .style('stroke-width', 0.5);


    function highlight(cities, province, data) {

        function update(year) {
          var filtered = nested.filter(function(d) {
            return new Date(d['key']).getUTCFullYear() === year ;
          });

        //debugger;

        d3.select("h2")
          .text("中国主要城市大气AQI分布 " + year);

        //debugger;

        var updateFeature = []

        for (var i = 0; i < filtered[0].values.length; i ++){
          var dataCity = filtered[0].values[i].key;
          var dataValue = parseFloat(filtered[0].values[i].values.aveAQI);
          for (var j = 0; j < cities.features.length; j++) {
            var jsonCity = cities.features[j].properties.name;
            if (dataCity == jsonCity) {
              cities.features[j].properties.value = dataValue;
              updateFeature.push(cities.features[j]);
              break;
            }
          }
        } //insert aqi value into geojson file


        //debugger;

        var seleCities = svg.selectAll('.cities')
                            .data(updateFeature);



        seleCities.enter().append('path');
        seleCities.exit().remove();
          //  .append('path')
          //  .exit()
          //  .remove();
           //.transition()
           //.duration(500)
        seleCities.attr('d', path)
           .attr('class', 'cities')
           .style('fill', function(d){
             var value = d.properties.value;
             //if (value) {
               return color(value);
             //} else {
               return "#fff5eb";
             //}
           })
           .style('stroke', 'green')
           .style('stroke-width', 0.2);
          }



      var year = []

      nested.forEach(function(d){
        //console.log(Object.prototype.toString.call(d['key']));
        year.push(d['key'])
      });

      //debugger;
      var year_index = 0

      var year_interval = setInterval(function(){
        update(Number(year[year_index]));
        //debugger;
        year_index++;
        if (year_index >= year.length) {
          clearInterval(year_interval)
        }
      },1000);
    };

    highlight(cities, province, data);
};
  </script>
</body>
</html>
